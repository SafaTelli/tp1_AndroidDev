{
    "docs": [
        {
            "location": "/", 
            "text": "Travaux Pratiques D\u00e9veloppement mobile\n\n\nRT4 - INSAT\n\n\n\n\n\n\nCours Disponible ici: http://liliasfaxi.wixsite.com/liliasfaxi/android\n\n\nPiazza : https://piazza.com/class/j3k0yr6cyex4n8\n\n\nRepo Github :  https://github.com/INSATunisia\n\n\n\n\nOverview\n\n\nL'objectif de ce cours est d'initier les \u00e9tudiants au d\u00e9veloppement Android. \u00c0 la fin de ce cours, les \u00e9tudiants doivent maitriser les notions suivantes :\n\n\n\n\nLes composants graphiques sous Android.\n\n\nLa navigation et la communication entre les application Android.\n\n\nLa manipulation des donn\u00e9es ( fichiers, BD interne ...).\n\n\nLa communication avec les services web.\n\n\n\n\nCe cours comporte cinq s\u00e9ances de travaux pratiques:\n\n\n\n\nTP1: E\u0301le\u0301ments Graphiques de base et Intents\n\n\nTP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : Adaptateurs \n Listes\n\n\nTP3: E\u0301le\u0301ments Graphiques avanc\u00e9s : Fragments \n Menus\n\n\nTP4: Base de donn\u00e9es internes/ Firebase\n\n\nTP5: Connexion \u00e0 des services web REST : Retrofit", 
            "title": "Travaux Pratiques D\u00e9veloppement mobile"
        }, 
        {
            "location": "/#travaux-pratiques-developpement-mobile", 
            "text": "", 
            "title": "Travaux Pratiques D\u00e9veloppement mobile"
        }, 
        {
            "location": "/#rt4-insat", 
            "text": "Cours Disponible ici: http://liliasfaxi.wixsite.com/liliasfaxi/android  Piazza : https://piazza.com/class/j3k0yr6cyex4n8  Repo Github :  https://github.com/INSATunisia", 
            "title": "RT4 - INSAT"
        }, 
        {
            "location": "/#overview", 
            "text": "L'objectif de ce cours est d'initier les \u00e9tudiants au d\u00e9veloppement Android. \u00c0 la fin de ce cours, les \u00e9tudiants doivent maitriser les notions suivantes :   Les composants graphiques sous Android.  La navigation et la communication entre les application Android.  La manipulation des donn\u00e9es ( fichiers, BD interne ...).  La communication avec les services web.   Ce cours comporte cinq s\u00e9ances de travaux pratiques:   TP1: E\u0301le\u0301ments Graphiques de base et Intents  TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : Adaptateurs   Listes  TP3: E\u0301le\u0301ments Graphiques avanc\u00e9s : Fragments   Menus  TP4: Base de donn\u00e9es internes/ Firebase  TP5: Connexion \u00e0 des services web REST : Retrofit", 
            "title": "Overview"
        }, 
        {
            "location": "/tp1/", 
            "text": "TP1 - E\u0301le\u0301ments Graphiques de base et Intents\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\nCr\u00e9ation et manipulation d\u2019\u00e9l\u00e9ments graphiques de base dans Android, et familiarisation avec la notion d\u2019intent, implicite et explicite.\n\n\nOutils et Versions\n\n\n\n\nAndroid Studio\n Version: 3.0.1\n\n\nAndroid : Version 5.0.1 ( API 21 )\n\n\n\n\nI. View et ViewGroup\n\n\n1. Le Composant View\n\n\nLa classe View repr\u00e9sente la classe de base pour la cr\u00e9ation d\u2019une interface graphique en Android. C\u2019est la classe m\u00e8re de tous les widgets (\u00e9l\u00e9ments graphiques), utilis\u00e9s pour cr\u00e9er des composants graphiques interactifs (boutons, champs texte, champs de saisie\u2026).\nUne vue occupe un espace rectangulaire sur l\u2019\u00e9cran, responsable de la gestion des \u00e9v\u00e8nements initi\u00e9s par l\u2019utilisateur.\nUne sous-classe ViewGroup est d\u00e9finie par Android, repr\u00e9sentant la classe de base pour tous les layouts (dispositions), qui sont des conteneurs invisibles qui rassemblent plusieurs View ou ViewGroup, et d\u00e9finissent leur emplacement dans l\u2019\u00e9cran (d\u00e9taill\u00e9s dans la section 2 : Les Layouts ).\n\n\n2. Les Layouts\n\n\nChaque \u00e9l\u00e9ment d\u2019une interface graphique est soit un objet View, soit ViewGroup. Les dispositions de ces \u00e9l\u00e9ments dans l\u2019\u00e9cran sont pr\u00e9cis\u00e9es principalement par des Layouts.\nUn Layout est un ViewGroup qui regroupe un ensemble de widgets ou d\u2019autres layouts, permettant ainsi de d\u00e9finir leur disposition sur l\u2019\u00e9cran de la fen\u00eatre principale. Parmi les layouts existants, on cite le FrameLayout, LinearLayout, RelativeLayout\u2026\n\n\nII. Exercice 1\u00a0: Composants Graphiques de Base\n\n\n1. Objectif\n\n\nL\u2019objectif de cette premi\u00e8re partie est de r\u00e9aliser une application de calcul d'IMC\n(Indice de Masse Corporelle) ayant une interface semblable \u00e0 ce qui suit\u00a0(veiller \u00e0 respecter les tailles et emplacements des \u00e9l\u00e9ments graphiques):\n\n\n\n\n\n\nActivit\u00e9 1\n : Commencer par cr\u00e9er l\u2019interface graphique, identique \u00e0 la figure qui pr\u00e9c\u00e8de. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.\n\n\n\n\n2. Comportement du bouton\n\n\nSoit le bouton d\u00e9fini dans le fichier main.xml, dont l\u2019identifiant est b_calcul. Pour manipuler ce bouton, trois m\u00e9thodes principales sont en g\u00e9n\u00e9ral utilis\u00e9es:\n\n\nM\u00e9thode 1: Surcharge du Listener du bouton\n\n\nEn Java, un Listener (\u00e9couteur) est un objet permettant au programmeur de r\u00e9agir suite aux actions de l\u2019utilisateur (clic de souris, touche du clavier, etc.). Dans notre cas, nous avons besoin d\u2019un \u00e9couteur pour le clic sur le bouton, appel\u00e9 onClickListener. Listener est une interface, qui fournit des m\u00e9thodes qui doivent \u00eatre impl\u00e9ment\u00e9es par le programmeur. Par exemple, le onClickListener contient une m\u00e9thode onClick, qu\u2019on doit impl\u00e9menter pour d\u00e9finir le comportement de notre bouton.\n\n\n\n\n1\n : Cr\u00e9er un attribut dans votre activit\u00e9 de type Button\u00a0:\n\n\n\n\n  \nprivate\n \nButton\n \nbCalcul\n;\n\n\n\n\n\n\n\n\n2\n : Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut bConvert en lui associant le bouton cr\u00e9\u00e9 dans le main.xml\u00a0:\n\n\n\n\nthis\n.\nbCalcul\n \n=\n \n(\nButton\n)\n \nthis\n.\nfindViewById\n(\nR\n.\nid\n.\nb_calcul\n)\n\u00a0\n;\n\n\n\n\n\n\n\n\n3\n : Utiliser le code suivant pour d\u00e9finir  le comportement du bouton bConvert (de pr\u00e9f\u00e9rence \u00e0 l\u2019int\u00e9rieur de la m\u00e9thode onCreate).\n\n\n\n\nthis\n.\nbCalcul\n.\nsetOnClickListener\n(\nnew\n \nOnClickListener\n()\n \n{\n\n    \n@Override\n\n       \npublic\n \nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n        \n//comportement de votre bouton\n\n       \n}\n\n\n});\n\n\n\n\n\n\nM\u00e9thode 2\u00a0: D\u00e9finition d\u2019une m\u00e9thode propre au bouton\n\n\nIl existe une mani\u00e8re moins encombrante de d\u00e9finir le comportement du bouton, mais qui ne peut pas s\u2019appliquer \u00e0 tous les \u00e9v\u00e8nements, seulement au clic.\n\n\n\n\n1\n : Dans l\u2019\u00e9l\u00e9ment XML du bouton, ajouter l\u2019attribut\u00a0:\n\n\n\n\nandroid:onClick=\ncalcul\n\n\n\n\n\n\nCet attribut indique qu\u2019il existe une m\u00e9thode dans le code de l\u2019activit\u00e9, appel\u00e9e calcul, qui d\u00e9finit le comportement du bouton au clic.\n\n\n\n\n2\n : Dans le code de l\u2019activit\u00e9, ajouter la m\u00e9thode suivante\u00a0:\n\n\n\n\npublic\n \nvoid\n \ncalcul\n(\nView\n \nv\n){\n\n\n// comportement du bouton\n\n\n}\n\n\n\n\n\n\nLa m\u00e9thode calcul ainsi d\u00e9finie a une signature particuli\u00e8re\u00a0: elle doit obligatoirement \u00eatre publique, retourner void et prendre comme param\u00e8tre un objet de type android.view.View (vous remarquerez que cette m\u00e9thode a la m\u00eame signature que la m\u00e9thode onClick, surcharg\u00e9e dans la premi\u00e8re m\u00e9thode). Il faut noter \u00e9galement que la vue v pass\u00e9e en param\u00e8tre, correspond \u00e0 l\u2019objet cliqu\u00e9.\n\n\n\n\nRemarque\n\n\nSi vous utilisez cette solution, il est inutile de d\u00e9finir une variable de type Button en Java, et de l\u2019associer au bouton d\u00e9fini dans le fichier XML.\n\n\n\n\nM\u00e9thode 3\u00a0: Impl\u00e9mentation de l\u2019interface OnClickListener\n\n\nIl est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes\u00a0:\n\n\n\n\n1\n : Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 en transformant la signature de votre classe activit\u00e9 comme suit, par exemple\u00a0:\n\n\n\n\npublic\n \nclass\n \nIMC\n  \nextends\n \nActivity\n \nimplements\n \nOnClickListener\n \n{\n\u2026\n}\n\n\n\n\n\n\n\n\n\n\n2\n : Cr\u00e9er l\u2019attribut bCalcul de type Button\u00a0et l\u2019associer \u00e0 l\u2019\u00e9l\u00e9ment XML b_calcul, comme dans la m\u00e9thode 1.\n\n\n\n\n\n\n3\n : D\u00e9finir l\u2019activit\u00e9 courante comme \u00e9tant l\u2019\u00e9couteur du clic sur le bouton bCalcul :\n\n\n\n\n\n\nbCalcul\n.\nsetOnClickListener\n(\nthis\n);\n\n\n\n\n\n\n\n\n4\n : Ajouter la m\u00e9thode onClick dans votre activit\u00e9, comme suit\u00a0:\n\n\n\n\npublic\n \nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n        \nif\n \n(\nv\n.\ngetId\n()==\nR\n.\nid\n.\nb_calcul\n){\n\n            \n//Comportement du bouton b_convert\n\n            \n}\n\n        \n}\n\n\n\n\n\n\n\n\nAttention\n\n\nCette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9.\n\n\n\n\nCette m\u00e9thode peut s\u2019av\u00e9rer utile dans le cas o\u00f9 on voudrait par exemple regrouper les impl\u00e9mentations de tous les boutons de l\u2019interface dans la m\u00eame m\u00e9thode, ou si plusieurs boutons partageaient une partie de leur comportement.\n\n\n3. Comportement d\u2019un EditText\n\n\nUn EditText est un objet graphique qui permet \u00e0 l\u2019utilisateur de saisir une cha\u00eene de caract\u00e8res, utilisable par l\u2019application.\nDe m\u00eame que pour le bouton (ainsi que tous les \u00e9l\u00e9ments graphiques que nous d\u00e9sirons utiliser dans notre application), nous devons d\u00e9finir et initialiser un objet Java associ\u00e9 au champs EditText\u00a0:\n\n\n\n\n1\n : Cr\u00e9er un attribut dans votre activit\u00e9 de type EditText:\n\n\n\n\nprivate\n \nEditText\n \neEntry\n;\n\n\n\n\n\n\n\n\n2\n : Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut eEntree en lui associant le champs de saisie cr\u00e9\u00e9 dans le main.xml\u00a0:\n\n\n\n\nthis\n.\neEntry\n \n=\n \n(\nEditText\n)\n \nthis\n.\nfindViewById\n(\nR\n.\nid\n.\ne_entry\n)\n\u00a0\n;\n\n\n\n\n\n\n\n\n3\n : D\u00e9finir son comportement. Pour un champs de saisie, les principales fonctionnalit\u00e9s sont\u00a0:\n\n\nLa lecture du contenu\u00a0: pour cela on utilise la m\u00e9thode\u00a0:\n\n\n\n\n\n\n\n\nString\n \ns\n \n=\n \neEntry\n.\ngetText\n().\ntoString\n();\n\n\n\n\n\n\n* La modification du contenu\u00a0:\n\n\n\n\n\neEntry\n.\nsetText\n(\nNouveau texte\u00a0\n);\n\n\n\n\n\n\n4. Comportement d\u2019un TextView\n\n\nUn TextView est un objet graphique qui permet d\u2019afficher une cha\u00eene de caract\u00e8res non-\u00e9ditable par l\u2019utilisateur. Le TextView peut \u00eatre utilis\u00e9 par l\u2019application exactement de la m\u00eame mani\u00e8re qu\u2019un EditText.\n\n\n5. Comportement d\u2019un Bouton Radio\n\n\nUn bouton radio est un bouton \u00e0 deux \u00e9tats qui peut \u00eatre soit coch\u00e9 (checked) ou d\u00e9coch\u00e9 (unchecked). Les boutons radios sont en g\u00e9n\u00e9ral utilis\u00e9s dans un groupe RadioGroup. Au sein d\u2019un m\u00eame groupe, un seul bouton radio peut \u00eatre coch\u00e9.\n\n\nPour g\u00e9rer l\u2019\u00e9tat d\u2019un bouton radio, il faut suivre les \u00e9tapes suivantes\u00a0:\n\n\n\n\n\n\nCr\u00e9er un attribut de type RadioButton dans votre activit\u00e9 (par exemple rHomme).\n\n\n\n\n\n\nL\u2019associer au bouton radio appropri\u00e9 de votre interface en utilisant la m\u00e9thode findViewById.\n\n\n\n\n\n\nPour tester l\u2019\u00e9tat de votre bouton radio, appeler la m\u00e9thode isChecked().\n\n\n\n\n\n\nif\n \n(\nrHomme\n.\nisChecked\n()\n \n){\n\n        \n//traitement\n\n\n}\n\n\n\n\n\n\nPour mettre \u00e0 jour l\u2019\u00e9tat du bouton radio, utiliser la m\u00e9thode setChecked(boolean etat). Par exemple, si on veut cocher l\u2019\u00e9l\u00e9ment radio1 et d\u00e9cocher radio2, on peut faire comme suit\u00a0:\n\n\nradio1\n.\nsetChecked\n(\ntrue\n);\n\n\nradio2\n.\nsetChecked\n(\nfalse\n);\n\n\n\n\n\n\n\n\nRemarques\n\n\n\n\n1\n Pour utiliser les boutons radios, il est inutile de d\u00e9finir des variables en Java pour le RadioGroup.\n\n\n2\n  Dans l\u2019exemple pr\u00e9c\u00e9dent (4), si radio1 et radio2 se trouvent dans un RadioGroup, il est inutile de changer leurs deux \u00e9tats\u00a0: le changement de l\u2019\u00e9tat de l\u2019un va automatiquement changer l\u2019autre, puisqu\u2019un seul peut \u00eatre coch\u00e9 \u00e0 la fois.\n\n\n\n\n\n\n6. Manipulation des ressources\n\n\nCouleurs\n\n\nPour ajouter une nouvelle couleur, il suffit de modifier le fichier colors.xml qui se trouve sous le r\u00e9pertoire values en ins\u00e9rant les lignes suivantes :\n\n\nresources\n\n    \ncolor\n \nname=\ncolorPrimary\n#3F51B5\n/color\n\n    \ncolor\n \nname=\ncolorPrimaryDark\n#303F9F\n/color\n\n    \ncolor\n \nname=\ncolorAccent\n#FF4081\n/color\n\n    \ncolor\n \nname=\ncolorRed\n#D50000\n/color\n\n    \ncolor\n \nname=\ncolorGreen\n#2E7D32\n/color\n\n    \ncolor\n \nname=\ncolorOrange\n#E65100\n/color\n\n\n\n/resources\n\n\n\n\n\n\nPour changer la couleur d'un TextView dynamiquement, il faut utiliser la fonction setTextColor(int color) de la classe TextView.\n\n\nexemple :\n\n\n  \ntextInterp\n.\nsetTextColor\n(\ngetResources\n().\ngetColor\n(\nR\n.\ncolor\n.\ncolorRed\n));\n\n\n\n\n\n\n\n\nactivit\u00e9 2\n : D\u00e9finir maintenant le comportement des diff\u00e9rents composants de votre interface en utilisant la m\u00e9thode de votre choix.\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\n1\n Le calcul d'IMC se fait comme suit: IMC = masse / taille\u00b2\n\n\n\n\n\n\n2\n L'interpr\u00e9tation de l'IMC se fait selon les crit\u00e8res d\u00e9finis par l'Organisation mondiale de la Sant\u00e9.\n  \n\n\n\n\n\n\n\n\nIII. Exercice 2\u00a0: Intents\n\n\n1. Objectif\n\n\nDur\u00e9e estim\u00e9e de l\u2019exercice\u00a0: au plus 1h\n\n\nL\u2019objectif de cette deuxi\u00e8me partie est de modifier l\u2019application de la premi\u00e8re partie pour obtenir le r\u00e9sultat suivant :\n\n\n\n\n2. Intents: D\u00e9finition\n\n\nUne application Android peut contenir plusieurs activit\u00e9s. Une activit\u00e9 utilise la m\u00e9thode setContentView pour s\u2019associer avec une interface graphique. \u00c0 la base, les activit\u00e9s sont ind\u00e9pendantes les unes des autres, cependant, elles peuvent collaborer pour \u00e9changer des donn\u00e9es et des actions.\n\n\nTypiquement, l\u2019une des activit\u00e9s est d\u00e9sign\u00e9e comme \u00e9tant la premi\u00e8re \u00e0 \u00eatre pr\u00e9sent\u00e9e \u00e0 l\u2019utilisateur quand l\u2019application est lanc\u00e9e\u00a0: on l\u2019appelle l\u2019activit\u00e9 de d\u00e9marrage. Toutes les activit\u00e9s interagissent en mode asynchrone.\n\n\nLe passage d\u2019une activit\u00e9 \u00e0 une autre est r\u00e9alis\u00e9 en demandant \u00e0 l\u2019activit\u00e9 en cours d\u2019ex\u00e9cuter un Intent.\nUn intent est un message qui peut \u00eatre utilis\u00e9 pour demander une action \u00e0 partir d\u2019un composant de l\u2019application. Il permet invoquer des Activit\u00e9s, des Broadcast Receivers ou des Services. Les diff\u00e9rentes m\u00e9thodes utilis\u00e9es pour appeler ces composantes sont les suivantes\u00a0:\n\n\n\n\nstartActivity(intent)\u00a0: lance une activit\u00e9.\n\n\nsendBroadcast(intent)\u00a0:  envoie un intent \u00e0 tous les composants Broadcast Receivers int\u00e9ress\u00e9s.\n\n\nstartService(intent) ou bindService(intent, \u2026)\u00a0: communiquent avec un service en arri\u00e8re plan.\n\n\n\n\nUn intent comporte des informations que le syst\u00e8me Android utilise.\n\n\n\n\nNom du composant \u00e0 d\u00e9marrer\n\n\nAction \u00e0 r\u00e9aliser\u00a0: ACTION-VIEW, ACTION_SEND\u2026\n\n\nDonn\u00e9e\u00a0: URI r\u00e9f\u00e9ren\u00e7ant la donn\u00e9e sur laquelle l\u2019action va agir\n\n\nCat\u00e9gorie\u00a0: Information suppl\u00e9mentaire sur le type de composants qui va g\u00e9rer l\u2019intent, par exemple\u00a0: CATEGORY-BROWSABLE, CATEGORY-LAUNCHER\u2026\n\n\nExtras\u00a0: Paires clef-valeur qui comportent des informations additionnelles pour r\u00e9aliser l\u2019action demand\u00e9e.\n\n\nDrapeaux (Flags)\u00a0: D\u00e9finissent la classe qui fonctionne comme m\u00e9tadonn\u00e9e pour cet intent, ils peuvent indiquer comment lancer une activit\u00e9 et comment la traiter une fois lanc\u00e9e.\n\n\n\n\nIl existe principalement deux types d\u2019Intents\u00a0: Intents explicites et intents implicites.\n\n\n3. Intents Explicites\n\n\nLes intents explicites sp\u00e9cifient le composant \u00e0 d\u00e9marrer par nom (nom complet de la classe). Ils permettent de d\u00e9marrer un composant de votre propre application, car le nom de sa classe est connu. Par exemple: d\u00e9marrer une autre activit\u00e9 en r\u00e9ponse \u00e0 l\u2019action d\u2019un utilisateur.\n\n\nLes principaux arguments d\u2019un Intent explicite sont\u00a0:\n\n\n\n\n\n\nLe contexte d\u00e9clenchant l\u2019Intent (en g\u00e9n\u00e9ral this, si on le lance \u00e0 partir de l\u2019activit\u00e9 de d\u00e9part, ou bien \n.this).\n\n\n\n\n\n\nLa classe destination (en g\u00e9n\u00e9ral \n.class).\n\n\n\n\n\n\nIl est typiquement appel\u00e9 comme suit:\n\n\nIntent\n \nmyActivityIntent\n \n=\n\n        \nnew\n \nIntent\n \n(\nStartClass\n.\nthis\n,\n \nEndClass\n.\nclass\n)\n\u00a0\n;\n\n    \nstartActivity\n \n(\nmyActivityIntent\n)\n\u00a0\n;\n\n\n\n\n\n\nLes donn\u00e9es partag\u00e9es entre les deux activit\u00e9s peuvent \u00eatre envoy\u00e9es sous forme d\u2019Extras. Un extra est un \u00e9l\u00e9ment sous forme de clef/valeur, que l\u2019activit\u00e9 principale envoie \u00e0 l\u2019activit\u00e9 destination. Il est cr\u00e9\u00e9 comme suit\u00a0:\n\n\nmyActivityIntent\n.\nputExtra\n(\nclef\n,\nvaleur\n);\n\n\n\n\n\n\nAttention, tous les extras doivent \u00eatre associ\u00e9s \u00e0 l\u2019intent avant de d\u00e9clencher ce dernier dans le startActivity, bien s\u00fbr.\n\n\nIl est \u00e9galement possible de d\u00e9marrer une activit\u00e9 avec un r\u00e9sultat, en \u00e9tablissant un lien bidirectionnel entre deux activit\u00e9s. Pour recevoir un r\u00e9sultat \u00e0 partir d\u2019une autre activit\u00e9, appeler startActivityForResult au lieu de startActivity.\n\n\nL\u2019activit\u00e9 de destination doit bien s\u00fbr \u00eatre con\u00e7ue pour renvoyer un r\u00e9sultat une fois l\u2019op\u00e9ration r\u00e9alis\u00e9e, et ce sous forme d\u2019Intent. L\u2019activit\u00e9 principale le recevra et le traitera dans la m\u00e9thode pr\u00e9d\u00e9finie onActivityResult.\n\n\nVoici un exemple d\u2019un intent avec r\u00e9sultat :\n\n\n\n\n\n\nActivity1\n\n\n\n\n\n\n\n\nActivity2\n\n\n\n\n\n\n\n\nLe r\u00e9sultat obtenu par cet bout de code est le suivant :\n\n\n\n\n\n\nActivit\u00e9 3\n Commencer par cr\u00e9er l\u2019interface graphique de la deuxi\u00e8me activit\u00e9.\nImpl\u00e9menter ensuite le code du bouton back, qui permet de revenir \u00e0 l\u2019activit\u00e9\nprincipale en affichant le r\u00e9sultat trouv\u00e9 dans un toast.\n\n\n\n\n4. Intents Implicites\n\n\nLes intents implicites ne nomment pas un composant sp\u00e9cifique, mais d\u00e9clarent une action \u00e0 r\u00e9aliser. Ils permettent \u00e0 un composant d\u2019une application d\u2019appeler un autre composant, m\u00eame s\u2019il se trouve dans une autre application.\n\n\nExemple : montrer \u00e0 l\u2019utilisateur un emplacement sur une Map.\n\n\nLes principaux arguments d\u2019un Intent implicite sont\u00a0:\n\n\n\n\n\n\nAction\u00a0: l\u2019action \u00e0 r\u00e9aliser, peut \u00eatre pr\u00e9d\u00e9finie (ACTION_VIEW, ACTION_EDIT, ACTION_MAIN\u2026) ou cr\u00e9\u00e9e par l\u2019utilisateur.\n\n\n\n\n\n\nDonn\u00e9e\u00a0: Les donn\u00e9es principales sur lesquelles on va agir, tel que le num\u00e9ro de t\u00e9l\u00e9phone \u00e0 appeler.\n\n\n\n\n\n\nIl est typiquement appel\u00e9 comme suit:\n\n\nIntent\n \nmyActivityIntent\n \n=\n \nnew\n \nIntent\n \n(\naction\n,\n \ndonnee\n)\n\u00a0\n;\n\n\nstartActivity\n \n(\nmyActivityIntent\n)\n\u00a0\n;\n\n\n\n\n\n\nUn intent implicite se comporte comme suit:\n\n\n\n\n1.\n Activit\u00e9 A cr\u00e9e un Intent avec une action et le passe en param\u00e8tre \u00e0 startActivity.\n\n\n2.\n Le syst\u00e8me Android cherchent toutes les applications pour trouver un Intent Filter qui correspond \u00e0 cet Intent.\n\n\n3.\n Quand une correspondance est trouv\u00e9e, le syst\u00e8me d\u00e9marrent l\u2019activit\u00e9 (Activity B) en invoquant sa m\u00e9thode onCreate et en lui passant l\u2019intent.\n\n\n\n\n\n\nLes intents implicites utilisent la notion de Intent Filter pour trouver l\u2019activit\u00e9 destination \u00e0 d\u00e9clencher. Un Intent Filter est une expression dans le fichier Manifest d\u2019une application qui sp\u00e9cifie le type d\u2019intents que le composant veut recevoir. Il permet aux autres activit\u00e9s de lancer directement votre activit\u00e9 en utilisant un certain Intent.\n\n\nSi vous ne d\u00e9clarez pas d\u2019Intent Filters \u00e0 votre activit\u00e9, elle ne pourra \u00eatre d\u00e9clench\u00e9e que par un Intent Explicite. Il est n\u00e9anmoins recommand\u00e9 de ne pas d\u00e9clarer d\u2019Intent Filters pour les services, car cela peut causer des probl\u00e8mes de s\u00e9curit\u00e9.\n\n\nVoici un exemple d\u2019Intent Filter\u00a0:\n\n\n\nVoici un ensemble d\u2019actions commun\u00e9ment utilis\u00e9es\u00a0:\n\n\n\n\n\n\nAttention\n\n\nAttention, la plupart des actions n\u00e9cessitent des permissions \u00e0 ajouter dans le fichier manifest, par exemple, pour autoriser votre activit\u00e9 \u00e0 d\u00e9clencher un appel, il faut ajouter la ligne\u00a0:\n\n\n``` xml\n  \nuses-permission\n \nandroid:name=\nandroid.permission.CALL_PHONE\n/uses-permission\n\n```\n\n\n\n\n\n\n\nExemple d\u2019un Intent implicite qui permet d\u2019envoyer un message texte\u00a0:\n\n\n\nLa m\u00e9thode resolveActivity permet d\u2019\u00e9viter que l\u2019application crashe si l\u2019activit\u00e9 appel\u00e9e n\u2019existe pas. C\u2019est une sorte de gestion d\u2019exception.\n\n\nLe r\u00e9sultat obtenu sera alors comme suit\u00a0:\n\n\n\n\n\n\nActivit\u00e9 4 :\n Impl\u00e9menter ensuite le code du bouton call, qui permet de d\u00e9clencher automatiquement un appel sur un num\u00e9ro pr\u00e9d\u00e9fini.\n\n\n\n\nHomework\n\n\nVotre premier travail sera divis\u00e9 en 2 parties :\nEn premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle\u00a0:\n\n\nhttps://www.google.com/design/spec/material-design/introduction.html\n\n\nLire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques.\n\n\nEn deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant.\n\n\nL'application aura une principale interface, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander( Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter ( Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur qui contient un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil ( Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.", 
            "title": "TP1"
        }, 
        {
            "location": "/tp1/#tp1-elements-graphiques-de-base-et-intents", 
            "text": "", 
            "title": "TP1 - E\u0301le\u0301ments Graphiques de base et Intents"
        }, 
        {
            "location": "/tp1/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp1/#objectifs-du-tp", 
            "text": "Cr\u00e9ation et manipulation d\u2019\u00e9l\u00e9ments graphiques de base dans Android, et familiarisation avec la notion d\u2019intent, implicite et explicite.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp1/#outils-et-versions", 
            "text": "Android Studio  Version: 3.0.1  Android : Version 5.0.1 ( API 21 )", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp1/#i-view-et-viewgroup", 
            "text": "", 
            "title": "I. View et ViewGroup"
        }, 
        {
            "location": "/tp1/#1-le-composant-view", 
            "text": "La classe View repr\u00e9sente la classe de base pour la cr\u00e9ation d\u2019une interface graphique en Android. C\u2019est la classe m\u00e8re de tous les widgets (\u00e9l\u00e9ments graphiques), utilis\u00e9s pour cr\u00e9er des composants graphiques interactifs (boutons, champs texte, champs de saisie\u2026).\nUne vue occupe un espace rectangulaire sur l\u2019\u00e9cran, responsable de la gestion des \u00e9v\u00e8nements initi\u00e9s par l\u2019utilisateur.\nUne sous-classe ViewGroup est d\u00e9finie par Android, repr\u00e9sentant la classe de base pour tous les layouts (dispositions), qui sont des conteneurs invisibles qui rassemblent plusieurs View ou ViewGroup, et d\u00e9finissent leur emplacement dans l\u2019\u00e9cran (d\u00e9taill\u00e9s dans la section 2 : Les Layouts ).", 
            "title": "1. Le Composant View"
        }, 
        {
            "location": "/tp1/#2-les-layouts", 
            "text": "Chaque \u00e9l\u00e9ment d\u2019une interface graphique est soit un objet View, soit ViewGroup. Les dispositions de ces \u00e9l\u00e9ments dans l\u2019\u00e9cran sont pr\u00e9cis\u00e9es principalement par des Layouts.\nUn Layout est un ViewGroup qui regroupe un ensemble de widgets ou d\u2019autres layouts, permettant ainsi de d\u00e9finir leur disposition sur l\u2019\u00e9cran de la fen\u00eatre principale. Parmi les layouts existants, on cite le FrameLayout, LinearLayout, RelativeLayout\u2026", 
            "title": "2. Les Layouts"
        }, 
        {
            "location": "/tp1/#ii-exercice-1-composants-graphiques-de-base", 
            "text": "", 
            "title": "II. Exercice 1\u00a0: Composants Graphiques de Base"
        }, 
        {
            "location": "/tp1/#1-objectif", 
            "text": "L\u2019objectif de cette premi\u00e8re partie est de r\u00e9aliser une application de calcul d'IMC\n(Indice de Masse Corporelle) ayant une interface semblable \u00e0 ce qui suit\u00a0(veiller \u00e0 respecter les tailles et emplacements des \u00e9l\u00e9ments graphiques):    Activit\u00e9 1  : Commencer par cr\u00e9er l\u2019interface graphique, identique \u00e0 la figure qui pr\u00e9c\u00e8de. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.", 
            "title": "1. Objectif"
        }, 
        {
            "location": "/tp1/#2-comportement-du-bouton", 
            "text": "Soit le bouton d\u00e9fini dans le fichier main.xml, dont l\u2019identifiant est b_calcul. Pour manipuler ce bouton, trois m\u00e9thodes principales sont en g\u00e9n\u00e9ral utilis\u00e9es:", 
            "title": "2. Comportement du bouton"
        }, 
        {
            "location": "/tp1/#methode-1-surcharge-du-listener-du-bouton", 
            "text": "En Java, un Listener (\u00e9couteur) est un objet permettant au programmeur de r\u00e9agir suite aux actions de l\u2019utilisateur (clic de souris, touche du clavier, etc.). Dans notre cas, nous avons besoin d\u2019un \u00e9couteur pour le clic sur le bouton, appel\u00e9 onClickListener. Listener est une interface, qui fournit des m\u00e9thodes qui doivent \u00eatre impl\u00e9ment\u00e9es par le programmeur. Par exemple, le onClickListener contient une m\u00e9thode onClick, qu\u2019on doit impl\u00e9menter pour d\u00e9finir le comportement de notre bouton.   1  : Cr\u00e9er un attribut dans votre activit\u00e9 de type Button\u00a0:      private   Button   bCalcul ;    2  : Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut bConvert en lui associant le bouton cr\u00e9\u00e9 dans le main.xml\u00a0:   this . bCalcul   =   ( Button )   this . findViewById ( R . id . b_calcul ) \u00a0 ;    3  : Utiliser le code suivant pour d\u00e9finir  le comportement du bouton bConvert (de pr\u00e9f\u00e9rence \u00e0 l\u2019int\u00e9rieur de la m\u00e9thode onCreate).   this . bCalcul . setOnClickListener ( new   OnClickListener ()   { \n     @Override \n        public   void   onClick ( View   v )   { \n         //comportement de votre bouton \n        }  });", 
            "title": "M\u00e9thode 1: Surcharge du Listener du bouton"
        }, 
        {
            "location": "/tp1/#methode-2-definition-dune-methode-propre-au-bouton", 
            "text": "Il existe une mani\u00e8re moins encombrante de d\u00e9finir le comportement du bouton, mais qui ne peut pas s\u2019appliquer \u00e0 tous les \u00e9v\u00e8nements, seulement au clic.   1  : Dans l\u2019\u00e9l\u00e9ment XML du bouton, ajouter l\u2019attribut\u00a0:   android:onClick= calcul   Cet attribut indique qu\u2019il existe une m\u00e9thode dans le code de l\u2019activit\u00e9, appel\u00e9e calcul, qui d\u00e9finit le comportement du bouton au clic.   2  : Dans le code de l\u2019activit\u00e9, ajouter la m\u00e9thode suivante\u00a0:   public   void   calcul ( View   v ){  // comportement du bouton  }   La m\u00e9thode calcul ainsi d\u00e9finie a une signature particuli\u00e8re\u00a0: elle doit obligatoirement \u00eatre publique, retourner void et prendre comme param\u00e8tre un objet de type android.view.View (vous remarquerez que cette m\u00e9thode a la m\u00eame signature que la m\u00e9thode onClick, surcharg\u00e9e dans la premi\u00e8re m\u00e9thode). Il faut noter \u00e9galement que la vue v pass\u00e9e en param\u00e8tre, correspond \u00e0 l\u2019objet cliqu\u00e9.   Remarque  Si vous utilisez cette solution, il est inutile de d\u00e9finir une variable de type Button en Java, et de l\u2019associer au bouton d\u00e9fini dans le fichier XML.", 
            "title": "M\u00e9thode 2\u00a0: D\u00e9finition d\u2019une m\u00e9thode propre au bouton"
        }, 
        {
            "location": "/tp1/#methode-3-implementation-de-linterface-onclicklistener", 
            "text": "Il est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes\u00a0:   1  : Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 en transformant la signature de votre classe activit\u00e9 comme suit, par exemple\u00a0:   public   class   IMC    extends   Activity   implements   OnClickListener   { \u2026 }     2  : Cr\u00e9er l\u2019attribut bCalcul de type Button\u00a0et l\u2019associer \u00e0 l\u2019\u00e9l\u00e9ment XML b_calcul, comme dans la m\u00e9thode 1.    3  : D\u00e9finir l\u2019activit\u00e9 courante comme \u00e9tant l\u2019\u00e9couteur du clic sur le bouton bCalcul :    bCalcul . setOnClickListener ( this );    4  : Ajouter la m\u00e9thode onClick dans votre activit\u00e9, comme suit\u00a0:   public   void   onClick ( View   v )   { \n         if   ( v . getId ()== R . id . b_calcul ){ \n             //Comportement du bouton b_convert \n             } \n         }    Attention  Cette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9.   Cette m\u00e9thode peut s\u2019av\u00e9rer utile dans le cas o\u00f9 on voudrait par exemple regrouper les impl\u00e9mentations de tous les boutons de l\u2019interface dans la m\u00eame m\u00e9thode, ou si plusieurs boutons partageaient une partie de leur comportement.", 
            "title": "M\u00e9thode 3\u00a0: Impl\u00e9mentation de l\u2019interface OnClickListener"
        }, 
        {
            "location": "/tp1/#3-comportement-dun-edittext", 
            "text": "Un EditText est un objet graphique qui permet \u00e0 l\u2019utilisateur de saisir une cha\u00eene de caract\u00e8res, utilisable par l\u2019application.\nDe m\u00eame que pour le bouton (ainsi que tous les \u00e9l\u00e9ments graphiques que nous d\u00e9sirons utiliser dans notre application), nous devons d\u00e9finir et initialiser un objet Java associ\u00e9 au champs EditText\u00a0:   1  : Cr\u00e9er un attribut dans votre activit\u00e9 de type EditText:   private   EditText   eEntry ;    2  : Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut eEntree en lui associant le champs de saisie cr\u00e9\u00e9 dans le main.xml\u00a0:   this . eEntry   =   ( EditText )   this . findViewById ( R . id . e_entry ) \u00a0 ;    3  : D\u00e9finir son comportement. Pour un champs de saisie, les principales fonctionnalit\u00e9s sont\u00a0:  La lecture du contenu\u00a0: pour cela on utilise la m\u00e9thode\u00a0:     String   s   =   eEntry . getText (). toString ();   * La modification du contenu\u00a0:  eEntry . setText ( Nouveau texte\u00a0 );", 
            "title": "3. Comportement d\u2019un EditText"
        }, 
        {
            "location": "/tp1/#4-comportement-dun-textview", 
            "text": "Un TextView est un objet graphique qui permet d\u2019afficher une cha\u00eene de caract\u00e8res non-\u00e9ditable par l\u2019utilisateur. Le TextView peut \u00eatre utilis\u00e9 par l\u2019application exactement de la m\u00eame mani\u00e8re qu\u2019un EditText.", 
            "title": "4. Comportement d\u2019un TextView"
        }, 
        {
            "location": "/tp1/#5-comportement-dun-bouton-radio", 
            "text": "Un bouton radio est un bouton \u00e0 deux \u00e9tats qui peut \u00eatre soit coch\u00e9 (checked) ou d\u00e9coch\u00e9 (unchecked). Les boutons radios sont en g\u00e9n\u00e9ral utilis\u00e9s dans un groupe RadioGroup. Au sein d\u2019un m\u00eame groupe, un seul bouton radio peut \u00eatre coch\u00e9.  Pour g\u00e9rer l\u2019\u00e9tat d\u2019un bouton radio, il faut suivre les \u00e9tapes suivantes\u00a0:    Cr\u00e9er un attribut de type RadioButton dans votre activit\u00e9 (par exemple rHomme).    L\u2019associer au bouton radio appropri\u00e9 de votre interface en utilisant la m\u00e9thode findViewById.    Pour tester l\u2019\u00e9tat de votre bouton radio, appeler la m\u00e9thode isChecked().    if   ( rHomme . isChecked ()   ){ \n         //traitement  }   Pour mettre \u00e0 jour l\u2019\u00e9tat du bouton radio, utiliser la m\u00e9thode setChecked(boolean etat). Par exemple, si on veut cocher l\u2019\u00e9l\u00e9ment radio1 et d\u00e9cocher radio2, on peut faire comme suit\u00a0:  radio1 . setChecked ( true );  radio2 . setChecked ( false );    Remarques   1  Pour utiliser les boutons radios, il est inutile de d\u00e9finir des variables en Java pour le RadioGroup.  2   Dans l\u2019exemple pr\u00e9c\u00e9dent (4), si radio1 et radio2 se trouvent dans un RadioGroup, il est inutile de changer leurs deux \u00e9tats\u00a0: le changement de l\u2019\u00e9tat de l\u2019un va automatiquement changer l\u2019autre, puisqu\u2019un seul peut \u00eatre coch\u00e9 \u00e0 la fois.", 
            "title": "5. Comportement d\u2019un Bouton Radio"
        }, 
        {
            "location": "/tp1/#6-manipulation-des-ressources", 
            "text": "", 
            "title": "6. Manipulation des ressources"
        }, 
        {
            "location": "/tp1/#couleurs", 
            "text": "Pour ajouter une nouvelle couleur, il suffit de modifier le fichier colors.xml qui se trouve sous le r\u00e9pertoire values en ins\u00e9rant les lignes suivantes :  resources \n     color   name= colorPrimary #3F51B5 /color \n     color   name= colorPrimaryDark #303F9F /color \n     color   name= colorAccent #FF4081 /color \n     color   name= colorRed #D50000 /color \n     color   name= colorGreen #2E7D32 /color \n     color   name= colorOrange #E65100 /color  /resources   Pour changer la couleur d'un TextView dynamiquement, il faut utiliser la fonction setTextColor(int color) de la classe TextView.  exemple :     textInterp . setTextColor ( getResources (). getColor ( R . color . colorRed ));    activit\u00e9 2  : D\u00e9finir maintenant le comportement des diff\u00e9rents composants de votre interface en utilisant la m\u00e9thode de votre choix.    Notes    1  Le calcul d'IMC se fait comme suit: IMC = masse / taille\u00b2    2  L'interpr\u00e9tation de l'IMC se fait selon les crit\u00e8res d\u00e9finis par l'Organisation mondiale de la Sant\u00e9.", 
            "title": "Couleurs"
        }, 
        {
            "location": "/tp1/#iii-exercice-2-intents", 
            "text": "", 
            "title": "III. Exercice 2\u00a0: Intents"
        }, 
        {
            "location": "/tp1/#1-objectif_1", 
            "text": "Dur\u00e9e estim\u00e9e de l\u2019exercice\u00a0: au plus 1h  L\u2019objectif de cette deuxi\u00e8me partie est de modifier l\u2019application de la premi\u00e8re partie pour obtenir le r\u00e9sultat suivant :", 
            "title": "1. Objectif"
        }, 
        {
            "location": "/tp1/#2-intents-definition", 
            "text": "Une application Android peut contenir plusieurs activit\u00e9s. Une activit\u00e9 utilise la m\u00e9thode setContentView pour s\u2019associer avec une interface graphique. \u00c0 la base, les activit\u00e9s sont ind\u00e9pendantes les unes des autres, cependant, elles peuvent collaborer pour \u00e9changer des donn\u00e9es et des actions.  Typiquement, l\u2019une des activit\u00e9s est d\u00e9sign\u00e9e comme \u00e9tant la premi\u00e8re \u00e0 \u00eatre pr\u00e9sent\u00e9e \u00e0 l\u2019utilisateur quand l\u2019application est lanc\u00e9e\u00a0: on l\u2019appelle l\u2019activit\u00e9 de d\u00e9marrage. Toutes les activit\u00e9s interagissent en mode asynchrone.  Le passage d\u2019une activit\u00e9 \u00e0 une autre est r\u00e9alis\u00e9 en demandant \u00e0 l\u2019activit\u00e9 en cours d\u2019ex\u00e9cuter un Intent.\nUn intent est un message qui peut \u00eatre utilis\u00e9 pour demander une action \u00e0 partir d\u2019un composant de l\u2019application. Il permet invoquer des Activit\u00e9s, des Broadcast Receivers ou des Services. Les diff\u00e9rentes m\u00e9thodes utilis\u00e9es pour appeler ces composantes sont les suivantes\u00a0:   startActivity(intent)\u00a0: lance une activit\u00e9.  sendBroadcast(intent)\u00a0:  envoie un intent \u00e0 tous les composants Broadcast Receivers int\u00e9ress\u00e9s.  startService(intent) ou bindService(intent, \u2026)\u00a0: communiquent avec un service en arri\u00e8re plan.   Un intent comporte des informations que le syst\u00e8me Android utilise.   Nom du composant \u00e0 d\u00e9marrer  Action \u00e0 r\u00e9aliser\u00a0: ACTION-VIEW, ACTION_SEND\u2026  Donn\u00e9e\u00a0: URI r\u00e9f\u00e9ren\u00e7ant la donn\u00e9e sur laquelle l\u2019action va agir  Cat\u00e9gorie\u00a0: Information suppl\u00e9mentaire sur le type de composants qui va g\u00e9rer l\u2019intent, par exemple\u00a0: CATEGORY-BROWSABLE, CATEGORY-LAUNCHER\u2026  Extras\u00a0: Paires clef-valeur qui comportent des informations additionnelles pour r\u00e9aliser l\u2019action demand\u00e9e.  Drapeaux (Flags)\u00a0: D\u00e9finissent la classe qui fonctionne comme m\u00e9tadonn\u00e9e pour cet intent, ils peuvent indiquer comment lancer une activit\u00e9 et comment la traiter une fois lanc\u00e9e.   Il existe principalement deux types d\u2019Intents\u00a0: Intents explicites et intents implicites.", 
            "title": "2. Intents: D\u00e9finition"
        }, 
        {
            "location": "/tp1/#3-intents-explicites", 
            "text": "Les intents explicites sp\u00e9cifient le composant \u00e0 d\u00e9marrer par nom (nom complet de la classe). Ils permettent de d\u00e9marrer un composant de votre propre application, car le nom de sa classe est connu. Par exemple: d\u00e9marrer une autre activit\u00e9 en r\u00e9ponse \u00e0 l\u2019action d\u2019un utilisateur.  Les principaux arguments d\u2019un Intent explicite sont\u00a0:    Le contexte d\u00e9clenchant l\u2019Intent (en g\u00e9n\u00e9ral this, si on le lance \u00e0 partir de l\u2019activit\u00e9 de d\u00e9part, ou bien  .this).    La classe destination (en g\u00e9n\u00e9ral  .class).    Il est typiquement appel\u00e9 comme suit:  Intent   myActivityIntent   = \n         new   Intent   ( StartClass . this ,   EndClass . class ) \u00a0 ; \n     startActivity   ( myActivityIntent ) \u00a0 ;   Les donn\u00e9es partag\u00e9es entre les deux activit\u00e9s peuvent \u00eatre envoy\u00e9es sous forme d\u2019Extras. Un extra est un \u00e9l\u00e9ment sous forme de clef/valeur, que l\u2019activit\u00e9 principale envoie \u00e0 l\u2019activit\u00e9 destination. Il est cr\u00e9\u00e9 comme suit\u00a0:  myActivityIntent . putExtra ( clef , valeur );   Attention, tous les extras doivent \u00eatre associ\u00e9s \u00e0 l\u2019intent avant de d\u00e9clencher ce dernier dans le startActivity, bien s\u00fbr.  Il est \u00e9galement possible de d\u00e9marrer une activit\u00e9 avec un r\u00e9sultat, en \u00e9tablissant un lien bidirectionnel entre deux activit\u00e9s. Pour recevoir un r\u00e9sultat \u00e0 partir d\u2019une autre activit\u00e9, appeler startActivityForResult au lieu de startActivity.  L\u2019activit\u00e9 de destination doit bien s\u00fbr \u00eatre con\u00e7ue pour renvoyer un r\u00e9sultat une fois l\u2019op\u00e9ration r\u00e9alis\u00e9e, et ce sous forme d\u2019Intent. L\u2019activit\u00e9 principale le recevra et le traitera dans la m\u00e9thode pr\u00e9d\u00e9finie onActivityResult.  Voici un exemple d\u2019un intent avec r\u00e9sultat :    Activity1     Activity2     Le r\u00e9sultat obtenu par cet bout de code est le suivant :    Activit\u00e9 3  Commencer par cr\u00e9er l\u2019interface graphique de la deuxi\u00e8me activit\u00e9.\nImpl\u00e9menter ensuite le code du bouton back, qui permet de revenir \u00e0 l\u2019activit\u00e9\nprincipale en affichant le r\u00e9sultat trouv\u00e9 dans un toast.", 
            "title": "3. Intents Explicites"
        }, 
        {
            "location": "/tp1/#4-intents-implicites", 
            "text": "Les intents implicites ne nomment pas un composant sp\u00e9cifique, mais d\u00e9clarent une action \u00e0 r\u00e9aliser. Ils permettent \u00e0 un composant d\u2019une application d\u2019appeler un autre composant, m\u00eame s\u2019il se trouve dans une autre application.  Exemple : montrer \u00e0 l\u2019utilisateur un emplacement sur une Map.  Les principaux arguments d\u2019un Intent implicite sont\u00a0:    Action\u00a0: l\u2019action \u00e0 r\u00e9aliser, peut \u00eatre pr\u00e9d\u00e9finie (ACTION_VIEW, ACTION_EDIT, ACTION_MAIN\u2026) ou cr\u00e9\u00e9e par l\u2019utilisateur.    Donn\u00e9e\u00a0: Les donn\u00e9es principales sur lesquelles on va agir, tel que le num\u00e9ro de t\u00e9l\u00e9phone \u00e0 appeler.    Il est typiquement appel\u00e9 comme suit:  Intent   myActivityIntent   =   new   Intent   ( action ,   donnee ) \u00a0 ;  startActivity   ( myActivityIntent ) \u00a0 ;   Un intent implicite se comporte comme suit:   1.  Activit\u00e9 A cr\u00e9e un Intent avec une action et le passe en param\u00e8tre \u00e0 startActivity.  2.  Le syst\u00e8me Android cherchent toutes les applications pour trouver un Intent Filter qui correspond \u00e0 cet Intent.  3.  Quand une correspondance est trouv\u00e9e, le syst\u00e8me d\u00e9marrent l\u2019activit\u00e9 (Activity B) en invoquant sa m\u00e9thode onCreate et en lui passant l\u2019intent.    Les intents implicites utilisent la notion de Intent Filter pour trouver l\u2019activit\u00e9 destination \u00e0 d\u00e9clencher. Un Intent Filter est une expression dans le fichier Manifest d\u2019une application qui sp\u00e9cifie le type d\u2019intents que le composant veut recevoir. Il permet aux autres activit\u00e9s de lancer directement votre activit\u00e9 en utilisant un certain Intent.  Si vous ne d\u00e9clarez pas d\u2019Intent Filters \u00e0 votre activit\u00e9, elle ne pourra \u00eatre d\u00e9clench\u00e9e que par un Intent Explicite. Il est n\u00e9anmoins recommand\u00e9 de ne pas d\u00e9clarer d\u2019Intent Filters pour les services, car cela peut causer des probl\u00e8mes de s\u00e9curit\u00e9.  Voici un exemple d\u2019Intent Filter\u00a0:  Voici un ensemble d\u2019actions commun\u00e9ment utilis\u00e9es\u00a0:    Attention  Attention, la plupart des actions n\u00e9cessitent des permissions \u00e0 ajouter dans le fichier manifest, par exemple, pour autoriser votre activit\u00e9 \u00e0 d\u00e9clencher un appel, il faut ajouter la ligne\u00a0:  ``` xml\n   uses-permission   android:name= android.permission.CALL_PHONE /uses-permission \n```   Exemple d\u2019un Intent implicite qui permet d\u2019envoyer un message texte\u00a0:  La m\u00e9thode resolveActivity permet d\u2019\u00e9viter que l\u2019application crashe si l\u2019activit\u00e9 appel\u00e9e n\u2019existe pas. C\u2019est une sorte de gestion d\u2019exception.  Le r\u00e9sultat obtenu sera alors comme suit\u00a0:    Activit\u00e9 4 :  Impl\u00e9menter ensuite le code du bouton call, qui permet de d\u00e9clencher automatiquement un appel sur un num\u00e9ro pr\u00e9d\u00e9fini.", 
            "title": "4. Intents Implicites"
        }, 
        {
            "location": "/tp1/#homework", 
            "text": "Votre premier travail sera divis\u00e9 en 2 parties :\nEn premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle\u00a0:  https://www.google.com/design/spec/material-design/introduction.html  Lire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques.  En deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant.  L'application aura une principale interface, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander( Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter ( Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur qui contient un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil ( Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.", 
            "title": "Homework"
        }
    ]
}